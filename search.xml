<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对 I2C 总线协议的理解]]></title>
    <url>%2F2019%2F07%2F24%2F1%2F</url>
    <content type="text"><![CDATA[摘要： I2C 总线协议是一种非常普遍的协议，主要用在对于 master 主 (或者多个master) 与一个或者多个 slave 从设备之间的通信。 I2C 简要介绍I2C 全称 Inter-IC，由 Philip 公司在 80 年代发展起来，是一种简单的，低、中速的串行双向两线总线串口协议，包括 serial data (SDA) 和 serial clock (SCL)。其中 SDA 传输数据，SCL 为时钟。至今，I2C 已经是一种全球工厂的标准，被用在许多主要的 IC 制造中。特点包括：可以有多个主设备，支持主从通信模式，在同一时间，只能由两个设备占据总线，每个设备被唯一的地址编码。 图中给出了一个嵌入式系统中应用 I2C 的例子，其中包括一个主设备和多个从设备。Microcontroller or Processor 作为主设备控制连接在总线上的其他I2C设备。所有从设备都只用两个 pin 与主设备相接。 电学特性I2C 在同一条线上使用的是 Open-Drain/Open-Collector 加上一个 buffer ，这使得双向的数据流可以在一条单独的数据线上传输。 用在双向通信的 open-drain 设备Open-Drain 是指一种可以把总线拉到一个电压(通常是地)，或者释放总线，让它被一个上拉电阻拉高的输出。 图中给出了一个主从设备在SDA/SCL线上简单的示意图，包含一个 buffer 用来读取输入数据，一个下拉 mos 管来传输数据。这种设备只能够下拉到低或者上拉到高，这个原理导致了双向通信的产生。 Open-Drain 下拉总线如上文所诉，Open-Drain 能够将总线拉低， 或者释放总线让它被上拉电阻拉高，图中显示了将总线拉低时的电流走向。当我们想要逻辑部分传输一个低信号时，下拉 mos 管将被激活，这会导致其与地短接，从而使得总线被拉低。 Open-Drain 释放总线当主设备或者从设备想要传输一个高的逻辑时，可以选择关掉下拉 mos 管，从而使得电流只能从上方通过，然后由上拉电阻拉高，图中显示了这种情况下的电流走向。 I2C 串口I2C 的一般操作I2C 总线是一种双向串口标准，它使用被称为主设备的控制器来与其他从设备通信。从设备只有在被主设备“叫到”地址的时候才会传输数据。每一个连接在同一个 I2C 总线上的设备都有一个唯一的地址，许多的从设备需要进行配置来设置它的行为。这通常在主设备访问具有唯一寄存器地址的从设备的内部寄存器映射的时候完成。另外，一个设备可以有一个或者多个寄存器来存储或者写入数据。 物理上的 I2C 串口包括两条总线，serial clock (SCL) 和 serial data (SDA)。这两条线都需要通过一个上拉电阻连接到 Vcc。关于上拉电阻，它的大小是由 I2C 线上的电容所决定的，想知道具体的计算方式，可以参考 TI 的 SLVA689 文档。只有在总线空闲时才能够传输数据，在 STOP 信号之后，SDA 和 SCL 线都保持高的情况下，被认为时总线空闲状态。一般主设备与从设备通信有以下两种情况： 1 主设备想要传输数据到从设备： 主设备发送一个 START 信号然后寻址到想要的从设备地址 主设备将数据传输到从设备 主设备以 STOP 信号停止传输 2 主设备想要接受或者读取从设备中的数据： 主设备发送一个 START 信号，然后寻址到想要读取的从设备 主设备传输想要读的寄存器地址到从设备 主设备从从设备那里接受数据 主设备以 STOP 信号停止传输 START 和 STOPI2C 通信中，由主设备发送一个 START 信号表示开始，发送一个 STOP 信号表示停止。当 SCL 线为高的时候，如果 SDA 线有一个从高到低的变化，这就是一个 START 信号。当 SCL 线为高的时候，如果 SDA 线有一个从低到高的变化，那么这就是一个 STOP 信号。 重新开始信号 Repeated START (Sr)重新开始信号与 START 信号类似，不过它被用在代替一个 STOP 接着一个 START 信号的情况。它与 START 信号很像，但是又有所不同，因为它是发生在 STOP 信号之前的(当总线为忙)。这在主设备想要开始一个新的通信，但是又不想让总线由于 STOP 信号处于空闲状态时很有用，因为当总线由于 STOP 信号处于空闲状态时，这有可能会使得现在的主设备失去对总线的控制(在多主设备的环境下)。 数据有效性和字节格式 一位数据将在 SCL 的每个时钟脉冲时传输，在 SDA 线上一个字节包括八位数据，一个字节可能是表示一个设备的地址，寄存器的地址，写入从设备或者从从设备中读取的数据。数据从 Most Significant Bit (MSB) 开始传输，任何在 START 和 STOP 之间字节数据都可以从主设备传输到从设备。在 SDA 线上的数据，必须在 SCL 线为稳定保持高的情况下传输，如果不稳定的话，可能会符合 START 或者 STOP 的触发条件。 应答信号 ACK &amp; NACK任何一个字节的数据(包括地址)后面都会跟随一个从接收端发送的 ACK 应答信号。ACK 信号使得接收端与发送端能够进行通信，从而知道数据是否被成功的接收，或者有没有另一个信号被发送。 在接收端发送 ACK 信号之前，发送端需要释放 SDA 线。接收端需要在 ACK/NACK 的时钟周期内下拉 SDA 线来发送一个 ACK 信号，所以在这个时钟周期为高的时候，SDA 线为低(需要考虑 Setup- &amp; Hold- time)。当 SDA 线在 ACK/NACK 的时钟周期内保持为高的时候，这就是一个 NACK 信号，这里有几种产生 NACK 信号的情况： 1 接收端无法接收或者发送，因为它正在执行一些实时功能，并且没有准备好于注设备通信。2 在传输过程中，接收端收到了它无法理解的数据或者命令。3 在传输过程中，接收端无法接收更多的数据。4 主设备作为接收端时，向从设备发送“我已经接收完了数据”信号。 I2C 数据传输数据的传输或者接收是通过对从设备的寄存器进行读取或者写入操作来实现的。 寄存器是从设备内存中包含信息的位置，无论是配置信息，还是一些要发送回主机的采样数据。主设备必须将信息写入这些寄存器，以指示从设备执行任务。 虽然在 I2C 从设备中有寄存器是很常见的，但是请注意，并非所有的从设备都有寄存器。有些设备很简单，只有一个寄存器，所以想要写入数据的话，只需要在从设备的地址信息之后传输数据就行，而不需要传输寄存器的地址，类似的例子有 8 位的 I2C 开关，它只需要一位的信息去打开或者关闭通道，所以只需要一个寄存器，主设备只需要在地址信息之后直接传入要写入的数据就行。 在 I2C 总线中写入从设备 在写入过程中，主设备将发送一个 START 信号和一个从设备的地址(普通的为 7bits )加一位 R/W bit，这一位被设置为 0 来表示写入。在从设备发送 ACK 应答信号之后，主设备将会发送希望写入的寄存器的寄存器地址，接着，从设备将再次发送 ACK 应答信号，让这个主设备知道它已经准备好了。之后，主设备将开始发送数据到从设备，直到主设备将数据发送完(很多时候只是一个字节)，然后主设备将由一个 STOP 信号来停止传输。 在 I2C 总线中读取从设备 从从设备中读取数据于写入数据非常相似，为了从从设备中读取，主设备首先要指定它希望从中读取的从设备。这通过主设备发送地址和 R/W bit 为 0 (写入)，接着跟上希望读取的寄存器地址来完成。一旦从设备在此之后发送了 ACK 应答，主设备将再次发送一个 START 信号，然后跟上从设备地址于 R/W 为 1 (读取)。这个时候，从设备将相应读取操作，然后主设备释放 SDA 线，由从设备来控制 SDA 线传输数据，但是主设备仍然会继续提供时钟 SCL。在这个情况下，主设备变成了接收端，从设备编程了发送端。 知识补充I2C 协议中的数据 I2C 中共有三个模式，由上图列出，值得一提的是，I2C 一般是使用 7 bit来寻址，实际上也有 10 bit 的模式，能够使得 I2C 连接更多的设备。下图给出 7 bit 和 10 bit 的标准。 I2C 协议中的 Arbitration如果由两个主设备在同一个总线上，那么有一种情况可能会发生，那就是它们两个都想在同一时间控制总线，那么这种情况是怎么解决的呐？ 当这种情况发生的时候，他们将会产生几个时钟周期的 delay，然后这个时候，两个主设备将会被控制成，一个拉高，一个保持为低，此时拉高的作为主设备，在这个主设备的工作完成后，再执行另一个主设备的工作。 更多关于 I2C 的细节可以参考 TI 的 AN10216-01 文档。]]></content>
      <categories>
        <category>protocol</category>
      </categories>
      <tags>
        <tag>I2C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法的简要规则]]></title>
    <url>%2F2019%2F07%2F20%2F1%2F</url>
    <content type="text"><![CDATA[Markdown 语法的简要规则 标题在 Markdown 中，如果一段文字被定义为标题，只需要在这段文字前加#号即可，总共可有六级标题，即###### 列表无序列表只需在文字前加上-或*，有序列表则加上1. 2. 3.符号和文字间加空格 1 无序 1 2 无序 2 有序 1 有序 2引用只需要在文本前加入 &gt; 这种大于号即可 引用例子 图片与链接插入图片：插入图片需要插入图片的URL地址! [ ] ( )插入链接：Baidu比图片少一个!号 [ ] ( )粗体和斜体两个 * 包含文本是粗体，一个 * 包含一段文本是斜体 粗体 斜体 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框只需要三个`在首尾行把中间的代码包裹起来 1234567891011121314# 1 获取索引界面网页内容 def get_page_index(i): # 下载1页 # url = &apos;https://www.thepaper.cn/newsDetail_forward_2370041&apos; # 2下载多页，构造url paras = &#123; &apos;nodeids&apos;: 25635, &apos;pageidx&apos;: i &#125; url = &apos;https://www.thepaper.cn/load_index.jsp?&apos; + urlencode(paras) response = requests.get(url,headers = headers) if response.status_code == 200: return response.text # print(response.text) # 测试网页内容是否提取成功ok 下划线三个 * 号]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F19%2F1%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>HelloWorld</category>
      </categories>
      <tags>
        <tag>HelloWorld</tag>
      </tags>
  </entry>
</search>
